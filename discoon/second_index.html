<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>DISCOON â€” Coming Soon</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0b0c10; --bg2:#221c3a; --accent:#ffd900; --muted:#bfc0c8;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Orbitron,monospace;background:linear-gradient(160deg,var(--bg1),var(--bg2));color:#fff;overflow:hidden}
  /* full screen wrapper */
  .wrap{height:100%;width:100%;display:grid;place-items:center;position:relative;perspective:1400px}
  /* parallax layers stack */
  .scene{position:relative;width:min(920px,92vw);height:min(520px,78vh);border-radius:20px;overflow:visible;transform-style:preserve-3d}
  /* back glow / fog */
  .layer-back{
    position:absolute;inset:0;border-radius:22px;background:
      radial-gradient(600px 220px at 10% 20%, rgba(255,217,0,0.06), transparent 10%),
      radial-gradient(500px 200px at 90% 80%, rgba(0,255,255,0.03), transparent 10%),
      linear-gradient(180deg, rgba(255,255,255,0.02), transparent 20%);
    filter:blur(16px) saturate(1.1);z-index:0;transform:translateZ(-180px) scale(.98)
  }
  /* mid ground card */
  .card{
    position:relative;z-index:10;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));border-radius:18px;padding:42px 48px;backdrop-filter: blur(6px) contrast(1.05);
    box-shadow: 0 30px 80px rgba(2,6,20,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
    transform-style:preserve-3d; will-change:transform;
    display:flex;flex-direction:column;align-items:center;gap:12px;
    min-width:360px; max-width:840px;
  }
  /* holographic logo */
  .logo{
    font-size:clamp(28px,6vw,56px);letter-spacing:6px;font-weight:800;color:#fff;position:relative;
    text-transform:uppercase;
    -webkit-text-stroke: 1px rgba(0,0,0,0.25);
  }
  .logo::after{
    content:"DISCOON";position:absolute;left:0;top:0;pointer-events:none;
    mix-blend-mode:screen;filter:blur(8px);opacity:.45;
    background:linear-gradient(90deg,var(--accent),#ff4df0,#00e5ff);
    -webkit-background-clip:text;background-clip:text;color:transparent;
    transform:translateZ(40px) scale(1.02);
  }
  /* small glitch layers */
  .logo-glitch{position:absolute;inset:0;pointer-events:none;mix-blend-mode:screen}
  .tag{font-size:clamp(12px,2.6vw,18px);color:var(--muted);letter-spacing:1px}
  .count{color:var(--accent);font-weight:700;}
  /* button */
  .cta{margin-top:10px;padding:12px 28px;border-radius:999px;border:2px solid var(--accent);background:transparent;color:var(--accent);cursor:pointer;font-weight:700;letter-spacing:1px}
  .cta:hover{background:var(--accent);color:#111;box-shadow:0 8px 30px rgba(255,217,0,0.14)}
  /* dynamic shine element (follows gyro) */
  .shine{position:absolute;left:50%;top:45%;width:420px;height:420px;border-radius:50%;pointer-events:none;transform:translate(-50%,-50%) translateZ(40px);mix-blend-mode:screen;filter:blur(40px);opacity:.6;z-index:5}
  /* foreground decorative shapes */
  .fg-shape{position:absolute;width:140px;height:140px;border-radius:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);transform-style:preserve-3d;z-index:12}
  .fg1{right:6%;bottom:8%;transform:translateZ(60px) scale(.95)}
  .fg2{left:8%;top:6%;width:200px;height:120px;border-radius:28px;transform:translateZ(80px) scale(.95)}
  /* small helper UI */
  .controls{position:absolute;left:18px;bottom:18px;background:rgba(0,0,0,0.35);padding:10px;border-radius:10px;font-size:13px;color:#ddd;z-index:30}
  .controls button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;margin-right:6px}
  /* particle canvas overlay */
  canvas.particles{position:absolute;inset:0;width:100%;height:100%;z-index:1;pointer-events:none}
  /* responsive */
  @media (max-width:600px){ .scene{height:72vh} .fg-shape{display:none} .controls{left:10px;bottom:10px;padding:8px;font-size:12px} }
</style>
</head>
<body>

<div class="wrap" id="wrap">
  <!-- background glow -->
  <div class="layer-back" id="layerBack"></div>

  <div class="scene" id="scene">
    <canvas class="particles" id="particles"></canvas>

    <div class="card" id="card">
      <div style="position:relative;width:100%;display:flex;flex-direction:column;align-items:center">
        <div class="logo" id="logo">DISCOON</div>
        <div class="logo-glitch" id="logoGlitch" aria-hidden="true"></div>
      </div>

      <div class="tag">Graphic Designing &amp; Video Editing Studio</div>
      <div id="count" class="count">Launching soon</div>
      <button class="cta" id="cta">Stay Tuned</button>
    </div>

    <!-- dynamic shine -->
    <div class="shine" id="shine"></div>

    <!-- foreground shapes -->
    <div class="fg-shape fg1" id="fg1"></div>
    <div class="fg-shape fg2" id="fg2"></div>
  </div>

  <!-- small controls -->
  <div class="controls" id="controls">
    <button id="calibrateBtn">Calibrate</button>
    <button id="permBtn">Enable Gyro</button>
    <label style="margin-left:8px">Sensitivity <input id="sens" type="range" min="0.5" max="3" step="0.1" value="1" style="vertical-align:middle"></label>
  </div>
</div>

<script>
/* ---------------------------
  Advanced Gyro + Parallax Script
   - deviceorientation with iOS permission
   - mouse fallback
   - low-pass smoothing
   - calibration baseline
   - layered parallax transforms
   - particles affected by motion
----------------------------*/

(() => {
  // Elements
  const card = document.getElementById('card');
  const scene = document.getElementById('scene');
  const shine = document.getElementById('shine');
  const layerBack = document.getElementById('layerBack');
  const fg1 = document.getElementById('fg1');
  const fg2 = document.getElementById('fg2');
  const logoGlitch = document.getElementById('logoGlitch');
  const countEl = document.getElementById('count');
  const permBtn = document.getElementById('permBtn');
  const calibrateBtn = document.getElementById('calibrateBtn');
  const sensControl = document.getElementById('sens');
  const particlesCanvas = document.getElementById('particles');
  const ctx = particlesCanvas.getContext('2d');

  // resize canvas
  function resizeCanvas(){ particlesCanvas.width = scene.clientWidth; particlesCanvas.height = scene.clientHeight; }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // particles
  const particles = [];
  const P_COUNT = Math.round((particlesCanvas.width * particlesCanvas.height) / 9000);
  for(let i=0;i<P_COUNT;i++){
    particles.push({
      x: Math.random()*particlesCanvas.width,
      y: Math.random()*particlesCanvas.height,
      r: Math.random()*2+0.6,
      vx: (Math.random()-0.5)*0.3,
      vy: (Math.random()-0.5)*0.3,
      hue: 48 + Math.random()*40
    });
  }

  function drawParticles(forceX=0, forceY=0){
    ctx.clearRect(0,0,particlesCanvas.width,particlesCanvas.height);
    for(const p of particles){
      p.vx += forceX*0.002 * (p.r*0.6);
      p.vy += forceY*0.002 * (p.r*0.6);
      p.x += p.vx;
      p.y += p.vy;
      // wrap
      if(p.x < -5) p.x = particlesCanvas.width+5;
      if(p.x > particlesCanvas.width+5) p.x = -5;
      if(p.y < -5) p.y = particlesCanvas.height+5;
      if(p.y > particlesCanvas.height+5) p.y = -5;
      ctx.beginPath();
      ctx.fillStyle = `hsla(${p.hue},100%,60%,${0.18*p.r})`;
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  // smoothing helper (low-pass)
  function smooth(prev, next, alpha){
    return prev + (next - prev) * alpha;
  }

  // state
  let state = { rx:0, ry:0, rz:0 }; // raw readings (deg)
  let smoothState = { rx:0, ry:0, rz:0 };
  let baseline = { rx:0, ry:0, rz:0 };
  let hasBaseline = false;
  let lastTime = performance.now();

  // sensitivity (0.5 - 3)
  let sensitivity = parseFloat(sensControl.value);

  sensControl.addEventListener('input', ()=> sensitivity = parseFloat(sensControl.value));

  // calibration
  calibrateBtn.addEventListener('click', () => {
    baseline.rx = state.rx; baseline.ry = state.ry; baseline.rz = state.rz;
    hasBaseline = true;
    calibrateBtn.innerText = 'Calibrated';
    setTimeout(()=> calibrateBtn.innerText = 'Calibrate', 1500);
  });

  // iOS 13+ permission flow
  async function requestGyroPermission(){
    if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      try{
        const resp = await DeviceMotionEvent.requestPermission();
        if(resp === 'granted'){ permBtn.style.opacity=0.6; permBtn.disabled=true; return true; }
      }catch(e){ console.warn('perm err', e); }
      return false;
    }else{
      // non-iOS: nothing to request
      permBtn.style.opacity=0.6; permBtn.disabled=true;
      return true;
    }
  }

  permBtn.addEventListener('click', async ()=>{
    const ok = await requestGyroPermission();
    if(ok) permBtn.innerText = 'Gyro Enabled';
    else permBtn.innerText = 'Permission Denied';
  });

  // map degrees to transforms, with clamping
  function applyTransforms(){
    // compute relative (subtract baseline if calibrated)
    const rx = state.rx - (hasBaseline ? baseline.rx : 0);
    const ry = state.ry - (hasBaseline ? baseline.ry : 0);
    const rz = state.rz - (hasBaseline ? baseline.rz : 0);

    // smoothing alpha depends on frame time
    const now = performance.now(); const dt = Math.min(60, now - lastTime); lastTime = now;
    const alpha = 1 - Math.pow(0.01, dt/16); // adaptive smoothing
    smoothState.rx = smooth(smoothState.rx, rx, alpha);
    smoothState.ry = smooth(smoothState.ry, ry, alpha);
    smoothState.rz = smooth(smoothState.rz, rz, alpha);

    // sensitivity multiplier
    const multi = sensitivity * 0.8;

    // compute rotations (limited)
    const rotX = Math.max(-18, Math.min(18, smoothState.ry * multi)); // tilt forward/back controls rotateX
    const rotY = Math.max(-28, Math.min(28, -smoothState.rx * multi)); // tilt left/right controls rotateY

    // depth offsets for parallax
    const bgOffsetX = rotY * 1.2, bgOffsetY = rotX * 1.0;
    const fgOffsetX = rotY * 2.6, fgOffsetY = rotX * 2.2;
    const cardTranslateZ = 30 + Math.abs(rotX)+Math.abs(rotY);

    // apply transforms - card rotates
    card.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg) translateZ(${cardTranslateZ}px)`;

    // layered parallax (we move each layer in different amounts)
    layerBack.style.transform = `translate3d(${bgOffsetX*-.8}px, ${bgOffsetY*-.7}px, -220px)`;
    fg1.style.transform = `translate3d(${fgOffsetX*0.9}px, ${fgOffsetY*0.6}px, 60px) rotateZ(${rotY*0.6}deg)`;
    fg2.style.transform = `translate3d(${fgOffsetX*-.9}px, ${fgOffsetY*-.4}px, 80px) rotateZ(${rotY*-.8}deg)`;

    // shine position: map rotX/rotY to percent
    const sx = 50 + (rotY * 0.45);
    const sy = 45 + (rotX * 0.45);
    shine.style.background = `radial-gradient(circle at ${sx}% ${sy}%, rgba(255,230,0,0.14), rgba(0,255,255,0.06) 22%, transparent 35%)`;

    // logo glitch effect intensity
    const glitchStrength = Math.min(1.2, Math.max(0, (Math.abs(rotX)+Math.abs(rotY))/30));
    renderGlitch(glitchStrength);

    // update particle physics using rot values
    drawParticles(rotY, rotX);
  }

  // logo glitch rendering: create layered colored copies + subtle offsets
  function renderGlitch(strength){
    // create CSS mix of clipped layers using text-shadow-like effect
    const o = Math.round(strength*8);
    const r = o*1.2;
    // simple multi-layer text using background positions
    logoGlitch.innerHTML = `
      <div style="position:absolute;left:0;top:0;right:0;bottom:0;">
        <span style="position:absolute;left:${r}px;top:${-r}px;color:rgba(255,0,80,${0.35*strength});filter:blur(${1.5*strength}px)">DISCOON</span>
        <span style="position:absolute;left:${-r}px;top:${r}px;color:rgba(0,220,255,${0.28*strength});filter:blur(${1.5*strength}px)">DISCOON</span>
      </div>`;
    logoGlitch.style.opacity = Math.min(1, strength*1.2);
    logoGlitch.style.transform = `translateZ(${40 + strength*10}px)`;
  }

  // deviceorientation handler
  function onDeviceOrientation(e){
    // gamma: left-right (-90 to 90) -> rx
    // beta: front-back (-180 to 180) -> ry
    // alpha: compass rotation 0-360 -> rz
    const g = e.gamma ?? 0;
    const b = e.beta ?? 0;
    const a = e.alpha ?? 0;
    // normalize ranges a little
    state.rx = g; state.ry = b - 10; state.rz = a - 180;
    // apply transforms every event (will be smoothed)
    applyTransforms();
  }

  // mouse fallback (desktop)
  function onMouseMove(e){
    const rect = scene.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = (e.clientX - cx) / (rect.width/2); // -1..1
    const dy = (e.clientY - cy) / (rect.height/2);
    // map to pseudo degrees
    state.rx = dx * 30; // left-right
    state.ry = -dy * 20; // up-down
    state.rz = 0;
    applyTransforms();
  }

  // keyboard small nudges for testing
  window.addEventListener('keydown', (ev)=>{
    if(ev.key === 'ArrowLeft') state.rx -= 4;
    if(ev.key === 'ArrowRight') state.rx += 4;
    if(ev.key === 'ArrowUp') state.ry += 3;
    if(ev.key === 'ArrowDown') state.ry -= 3;
    applyTransforms();
  });

  // set up listeners: device first, else mouse
  function enableDeviceOrientation(){
    if(window.DeviceOrientationEvent){
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
      // also mouse fallback
      window.addEventListener('mousemove', onMouseMove, {passive:true});
    } else {
      // only mouse
      window.addEventListener('mousemove', onMouseMove, {passive:true});
    }
  }
  enableDeviceOrientation();

  // request permission on load for iOS devices to reduce friction
  (async function tryAutoPermission(){
    if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      permBtn.style.display = 'inline-block';
    } else {
      permBtn.style.display = 'none';
    }
  })();

  // simple ticking loop to ensure transforms update (for smooth animation)
  function tick(){
    applyTransforms();
    requestAnimationFrame(tick);
  }
  tick();

  // small "launching soon" timer text (just dynamic flair)
  (function launchText(){
    const phrases = ['Launching soon','Big things incoming','DISCOON â€” stay tuned','Crafting visuals & motion'];
    let idx=0;
    setInterval(()=>{ countEl.textContent = phrases[idx++ % phrases.length]; }, 2600);
  })();

  // initial tiny animation for card entrance
  setTimeout(()=>{ card.style.transition = 'transform 400ms cubic-bezier(.22,.9,.3,1), box-shadow 400ms'; card.style.transform += ' rotateX(0deg) rotateY(0deg)'; }, 400);

  // provide helpful UX hint on long-press for mobile
  let touchTimer=0;
  scene.addEventListener('touchstart', ()=>{ touchTimer = Date.now(); }, {passive:true});
  scene.addEventListener('touchend', ()=>{ if(Date.now()-touchTimer>900) alert('Tip: Use "Enable Gyro" to grant motion permission if asked by your OS'); }, {passive:true});

  // Make sure canvas draws initially
  drawParticles(0,0);
})();
</script>
</body>
</html>
